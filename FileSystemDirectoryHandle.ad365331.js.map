{"mappings":"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","sources":["<anon>","node_modules/.pnpm/native-file-system-adapter@3.0.1/node_modules/native-file-system-adapter/src/FileSystemDirectoryHandle.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-dc3d9956227d72e1.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/helpers/browser/esm-js-loader.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js"],"sourcesContent":["\nfunction $parcel$defineInteropFlag(a) {\n  Object.defineProperty(a, '__esModule', {value: true, configurable: true});\n}\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    var parcelRequire = $parcel$global[\"parcelRequire40f8\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"2Fv9o\", function(module, exports) {\n\n$parcel$defineInteropFlag(module.exports);\n\n$parcel$export(module.exports, \"FileSystemDirectoryHandle\", () => $1f1792f500151ec9$export$80c69d2381792bb3);\n$parcel$export(module.exports, \"default\", () => $1f1792f500151ec9$export$2e2bcd8739ae039);\n\nvar $bAgeV = parcelRequire(\"bAgeV\");\n\nvar $jG9Jm = parcelRequire(\"jG9Jm\");\nconst { GONE: $1f1792f500151ec9$var$GONE, MOD_ERR: $1f1792f500151ec9$var$MOD_ERR } = (0, $jG9Jm.errors);\nconst $1f1792f500151ec9$var$kAdapter = Symbol(\"adapter\");\n\n\n\nclass $1f1792f500151ec9$export$80c69d2381792bb3 extends (0, $bAgeV.default) {\n    /** @type {FileSystemDirectoryHandle} */ [$1f1792f500151ec9$var$kAdapter];\n    constructor(adapter){\n        super(adapter);\n        this[$1f1792f500151ec9$var$kAdapter] = adapter;\n    }\n    /**\n   * @param {string} name Name of the directory\n   * @param {object} [options]\n   * @param {boolean} [options.create] create the directory if don't exist\n   * @returns {Promise<FileSystemDirectoryHandle>}\n   */ async getDirectoryHandle(name, options = {}) {\n        if (name === \"\") throw new TypeError(`Name can't be an empty string.`);\n        if (name === \".\" || name === \"..\" || name.includes(\"/\")) throw new TypeError(`Name contains invalid characters.`);\n        options.create = !!options.create;\n        const handle = await this[$1f1792f500151ec9$var$kAdapter].getDirectoryHandle(name, options);\n        return new $1f1792f500151ec9$export$80c69d2381792bb3(handle);\n    }\n    /** @returns {AsyncGenerator<[string, FileSystemHandle | FileSystemDirectoryHandle]>} */ async *entries() {\n        const { FileSystemFileHandle: FileSystemFileHandle } = await (parcelRequire(\"7VOZI\"));\n        for await (const [_, entry] of this[$1f1792f500151ec9$var$kAdapter].entries())yield [\n            entry.name,\n            entry.kind === \"file\" ? new FileSystemFileHandle(entry) : new $1f1792f500151ec9$export$80c69d2381792bb3(entry)\n        ];\n    }\n    /** @deprecated use .entries() instead */ async *getEntries() {\n        const { FileSystemFileHandle: FileSystemFileHandle } = await (parcelRequire(\"7VOZI\"));\n        console.warn(\"deprecated, use .entries() instead\");\n        for await (let entry of this[$1f1792f500151ec9$var$kAdapter].entries())yield entry.kind === \"file\" ? new FileSystemFileHandle(entry) : new $1f1792f500151ec9$export$80c69d2381792bb3(entry);\n    }\n    /**\n   * @param {string} name Name of the file\n   * @param {object} [options]\n   * @param {boolean} [options.create] create the file if don't exist\n   */ async getFileHandle(name, options = {}) {\n        const { FileSystemFileHandle: FileSystemFileHandle } = await (parcelRequire(\"7VOZI\"));\n        if (name === \"\") throw new TypeError(`Name can't be an empty string.`);\n        if (name === \".\" || name === \"..\" || name.includes(\"/\")) throw new TypeError(`Name contains invalid characters.`);\n        options.create = !!options.create;\n        const handle = await this[$1f1792f500151ec9$var$kAdapter].getFileHandle(name, options);\n        return new FileSystemFileHandle(handle);\n    }\n    /**\n   * @param {string} name\n   * @param {object} [options]\n   * @param {boolean} [options.recursive]\n   */ async removeEntry(name, options = {}) {\n        if (name === \"\") throw new TypeError(`Name can't be an empty string.`);\n        if (name === \".\" || name === \"..\" || name.includes(\"/\")) throw new TypeError(`Name contains invalid characters.`);\n        options.recursive = !!options.recursive // cuz node's fs.rm require boolean\n        ;\n        return this[$1f1792f500151ec9$var$kAdapter].removeEntry(name, options);\n    }\n    async resolve(possibleDescendant) {\n        if (await possibleDescendant.isSameEntry(this)) return [];\n        const openSet = [\n            {\n                handle: this,\n                path: []\n            }\n        ];\n        while(openSet.length){\n            let { handle: current, path: path } = openSet.pop();\n            for await (const entry of current.values()){\n                if (await entry.isSameEntry(possibleDescendant)) return [\n                    ...path,\n                    entry.name\n                ];\n                if (entry.kind === \"directory\") openSet.push({\n                    handle: entry,\n                    path: [\n                        ...path,\n                        entry.name\n                    ]\n                });\n            }\n        }\n        return null;\n    }\n    async *keys() {\n        for await (const [name] of this[$1f1792f500151ec9$var$kAdapter].entries())yield name;\n    }\n    async *values() {\n        for await (const [_, entry] of this)yield entry;\n    }\n    [Symbol.asyncIterator]() {\n        return this.entries();\n    }\n}\nObject.defineProperty($1f1792f500151ec9$export$80c69d2381792bb3.prototype, Symbol.toStringTag, {\n    value: \"FileSystemDirectoryHandle\",\n    writable: false,\n    enumerable: false,\n    configurable: true\n});\nObject.defineProperties($1f1792f500151ec9$export$80c69d2381792bb3.prototype, {\n    getDirectoryHandle: {\n        enumerable: true\n    },\n    entries: {\n        enumerable: true\n    },\n    getFileHandle: {\n        enumerable: true\n    },\n    removeEntry: {\n        enumerable: true\n    }\n});\nif (globalThis.FileSystemDirectoryHandle) {\n    const proto = globalThis.FileSystemDirectoryHandle.prototype;\n    proto.resolve = async function resolve(possibleDescendant) {\n        if (await possibleDescendant.isSameEntry(this)) return [];\n        const openSet = [\n            {\n                handle: this,\n                path: []\n            }\n        ];\n        while(openSet.length){\n            let { handle: current, path: path } = openSet.pop();\n            for await (const entry of current.values()){\n                if (await entry.isSameEntry(possibleDescendant)) return [\n                    ...path,\n                    entry.name\n                ];\n                if (entry.kind === \"directory\") openSet.push({\n                    handle: entry,\n                    path: [\n                        ...path,\n                        entry.name\n                    ]\n                });\n            }\n        }\n        return null;\n    };\n    // Safari allows us operate on deleted files,\n    // so we need to check if they still exist.\n    // Hope to remove this one day.\n    async function ensureDoActuallyStillExist(handle) {\n        const root = await navigator.storage.getDirectory();\n        const path = await root.resolve(handle);\n        if (path === null) throw new DOMException(...$1f1792f500151ec9$var$GONE);\n    }\n    const entries = proto.entries;\n    proto.entries = async function*() {\n        await ensureDoActuallyStillExist(this);\n        yield* entries.call(this);\n    };\n    proto[Symbol.asyncIterator] = async function*() {\n        yield* this.entries();\n    };\n    const removeEntry = proto.removeEntry;\n    proto.removeEntry = async function(name, options = {}) {\n        return removeEntry.call(this, name, options).catch(async (err)=>{\n            const unknown = err instanceof DOMException && err.name === \"UnknownError\";\n            if (unknown && !options.recursive) {\n                const empty = (await entries.call(this).next()).done;\n                if (!empty) throw new DOMException(...$1f1792f500151ec9$var$MOD_ERR);\n            }\n            throw err;\n        });\n    };\n}\nvar $1f1792f500151ec9$export$2e2bcd8739ae039 = $1f1792f500151ec9$export$80c69d2381792bb3;\n\n});\nparcelRegister(\"7VOZI\", function(module, exports) {\n\nvar $3tgc8 = parcelRequire(\"3tgc8\");\nmodule.exports = $3tgc8(\"6hwdd\").then(()=>parcelRequire(\"ggMY5\"));\n\n});\nparcelRegister(\"3tgc8\", function(module, exports) {\n\"use strict\";\n\nfunction $2870a479be9f8614$var$load(id) {\n    // eslint-disable-next-line no-undef\n    return import((parcelRequire(\"1sMvO\")).resolve(id));\n}\nmodule.exports = $2870a479be9f8614$var$load;\n\n});\nparcelRegister(\"1sMvO\", function(module, exports) {\n\n$parcel$export(module.exports, \"register\", () => $110e0974a90676f8$export$6503ec6e8aabbaf, (v) => $110e0974a90676f8$export$6503ec6e8aabbaf = v);\n$parcel$export(module.exports, \"resolve\", () => $110e0974a90676f8$export$f7ad0328861e2f03, (v) => $110e0974a90676f8$export$f7ad0328861e2f03 = v);\nvar $110e0974a90676f8$export$6503ec6e8aabbaf;\nvar $110e0974a90676f8$export$f7ad0328861e2f03;\n\"use strict\";\nvar $110e0974a90676f8$var$mapping = new Map();\nfunction $110e0974a90676f8$var$register(baseUrl, manifest) {\n    for(var i = 0; i < manifest.length - 1; i += 2)$110e0974a90676f8$var$mapping.set(manifest[i], {\n        baseUrl: baseUrl,\n        path: manifest[i + 1]\n    });\n}\nfunction $110e0974a90676f8$var$resolve(id) {\n    var resolved = $110e0974a90676f8$var$mapping.get(id);\n    if (resolved == null) throw new Error(\"Could not resolve bundle with id \" + id);\n    return new URL(resolved.path, resolved.baseUrl).toString();\n}\n$110e0974a90676f8$export$6503ec6e8aabbaf = $110e0974a90676f8$var$register;\n$110e0974a90676f8$export$f7ad0328861e2f03 = $110e0974a90676f8$var$resolve;\n\n});\n\n\n\n\n\n//# sourceMappingURL=FileSystemDirectoryHandle.ad365331.js.map\n","import FileSystemHandle from './FileSystemHandle.js'\nimport { errors } from './util.js'\n\nconst { GONE, MOD_ERR } = errors\n\nconst kAdapter = Symbol('adapter')\n\nclass FileSystemDirectoryHandle extends FileSystemHandle {\n  /** @type {FileSystemDirectoryHandle} */\n  [kAdapter]\n\n  constructor (adapter) {\n    super(adapter)\n    this[kAdapter] = adapter\n  }\n\n  /**\n   * @param {string} name Name of the directory\n   * @param {object} [options]\n   * @param {boolean} [options.create] create the directory if don't exist\n   * @returns {Promise<FileSystemDirectoryHandle>}\n   */\n  async getDirectoryHandle (name, options = {}) {\n    if (name === '') {\n      throw new TypeError(`Name can't be an empty string.`)\n    }\n    if (name === '.' || name === '..' || name.includes('/')) {\n      throw new TypeError(`Name contains invalid characters.`)\n    }\n    options.create = !!options.create\n    const handle = await this[kAdapter].getDirectoryHandle(name, options)\n    return new FileSystemDirectoryHandle(handle)\n  }\n\n  /** @returns {AsyncGenerator<[string, FileSystemHandle | FileSystemDirectoryHandle]>} */\n  async * entries () {\n    const {FileSystemFileHandle} = await import('./FileSystemFileHandle.js')\n\n    for await (const [_, entry] of this[kAdapter].entries())\n      yield [entry.name, entry.kind === 'file'\n        ? new FileSystemFileHandle(entry)\n        : new FileSystemDirectoryHandle(entry)]\n  }\n\n  /** @deprecated use .entries() instead */\n  async * getEntries() {\n    const {FileSystemFileHandle} = await import('./FileSystemFileHandle.js')\n    console.warn('deprecated, use .entries() instead')\n    for await (let entry of this[kAdapter].entries())\n      yield entry.kind === 'file'\n        ? new FileSystemFileHandle(entry)\n        : new FileSystemDirectoryHandle(entry)\n  }\n\n  /**\n   * @param {string} name Name of the file\n   * @param {object} [options]\n   * @param {boolean} [options.create] create the file if don't exist\n   */\n  async getFileHandle (name, options = {}) {\n    const {FileSystemFileHandle} = await import('./FileSystemFileHandle.js')\n    if (name === '') throw new TypeError(`Name can't be an empty string.`)\n    if (name === '.' || name === '..' || name.includes('/')) {\n      throw new TypeError(`Name contains invalid characters.`)\n    }\n    options.create = !!options.create\n    const handle = await this[kAdapter].getFileHandle(name, options)\n    return new FileSystemFileHandle(handle)\n  }\n\n  /**\n   * @param {string} name\n   * @param {object} [options]\n   * @param {boolean} [options.recursive]\n   */\n  async removeEntry (name, options = {}) {\n    if (name === '') {\n      throw new TypeError(`Name can't be an empty string.`)\n    }\n    if (name === '.' || name === '..' || name.includes('/')) {\n      throw new TypeError(`Name contains invalid characters.`)\n    }\n    options.recursive = !!options.recursive // cuz node's fs.rm require boolean\n    return this[kAdapter].removeEntry(name, options)\n  }\n\n  async resolve (possibleDescendant) {\n    if (await possibleDescendant.isSameEntry(this)) {\n      return []\n    }\n\n    const openSet = [{ handle: this, path: [] }]\n\n    while (openSet.length) {\n      let { handle: current, path } = openSet.pop()\n\n      for await (const entry of current.values()) {\n        if (await entry.isSameEntry(possibleDescendant)) {\n          return [...path, entry.name]\n        }\n        if (entry.kind === 'directory') {\n          openSet.push({ handle: entry, path: [...path, entry.name] })\n        }\n      }\n    }\n\n    return null\n  }\n\n  async * keys () {\n    for await (const [name] of this[kAdapter].entries())\n      yield name\n  }\n\n  async * values () {\n    for await (const [_, entry] of this)\n      yield entry\n  }\n\n  [Symbol.asyncIterator]() {\n    return this.entries()\n  }\n}\n\nObject.defineProperty(FileSystemDirectoryHandle.prototype, Symbol.toStringTag, {\n\tvalue: 'FileSystemDirectoryHandle',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n})\n\nObject.defineProperties(FileSystemDirectoryHandle.prototype, {\n\tgetDirectoryHandle: { enumerable: true },\n\tentries: { enumerable: true },\n\tgetFileHandle: { enumerable: true },\n\tremoveEntry: { enumerable: true }\n})\n\nif (globalThis.FileSystemDirectoryHandle) {\n  const proto = globalThis.FileSystemDirectoryHandle.prototype\n\n  proto.resolve = async function resolve (possibleDescendant) {\n    if (await possibleDescendant.isSameEntry(this)) {\n      return []\n    }\n\n    const openSet = [{ handle: this, path: [] }]\n\n    while (openSet.length) {\n      let { handle: current, path } = openSet.pop()\n\n      for await (const entry of current.values()) {\n        if (await entry.isSameEntry(possibleDescendant)) {\n          return [...path, entry.name]\n        }\n        if (entry.kind === 'directory') {\n          openSet.push({ handle: entry, path: [...path, entry.name] })\n        }\n      }\n    }\n\n    return null\n  }\n\n  // Safari allows us operate on deleted files,\n  // so we need to check if they still exist.\n  // Hope to remove this one day.\n  async function ensureDoActuallyStillExist (handle) {\n    const root = await navigator.storage.getDirectory()\n    const path = await root.resolve(handle)\n    if (path === null) { throw new DOMException(...GONE) }\n  }\n\n  const entries = proto.entries\n  proto.entries = async function * () {\n    await ensureDoActuallyStillExist(this)\n    yield * entries.call(this)\n  }\n  proto[Symbol.asyncIterator] = async function * () {\n    yield * this.entries()\n  }\n\n  const removeEntry = proto.removeEntry\n  proto.removeEntry = async function (name, options = {}) {\n    return removeEntry.call(this, name, options).catch(async err => {\n      const unknown = err instanceof DOMException && err.name === 'UnknownError'\n      if (unknown && !options.recursive) {\n        const empty = (await entries.call(this).next()).done\n        if (!empty) { throw new DOMException(...MOD_ERR) }\n      }\n      throw err\n    })\n  }\n}\n\nexport default FileSystemDirectoryHandle\nexport { FileSystemDirectoryHandle }\n","let load = require('./helpers/browser/esm-js-loader');\nmodule.exports = (load(\"6hwdd\")).then(() => parcelRequire('ggMY5'));","\"use strict\";\n\nfunction load(id) {\n  // eslint-disable-next-line no-undef\n  return __parcel__import__(require('../bundle-manifest').resolve(id));\n}\nmodule.exports = load;","\"use strict\";\n\nvar mapping = new Map();\nfunction register(baseUrl, manifest) {\n  for (var i = 0; i < manifest.length - 1; i += 2) {\n    mapping.set(manifest[i], {\n      baseUrl: baseUrl,\n      path: manifest[i + 1]\n    });\n  }\n}\nfunction resolve(id) {\n  var resolved = mapping.get(id);\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n  return new URL(resolved.path, resolved.baseUrl).toString();\n}\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","parcelRequire","$parcel$global","globalThis","parcelRegister","register","module","exports","value","$1f1792f500151ec9$export$80c69d2381792bb3","$1f1792f500151ec9$export$2e2bcd8739ae039","$bAgeV","GONE","$1f1792f500151ec9$var$GONE","MOD_ERR","$1f1792f500151ec9$var$MOD_ERR","$jG9Jm","errors","$1f1792f500151ec9$var$kAdapter","Symbol","default","constructor","adapter","getDirectoryHandle","name","options","TypeError","includes","create","entries","FileSystemFileHandle","_","entry","kind","getEntries","console","warn","getFileHandle","removeEntry","recursive","resolve","possibleDescendant","isSameEntry","openSet","handle","path","length","current","pop","values","push","keys","asyncIterator","prototype","toStringTag","writable","defineProperties","FileSystemDirectoryHandle","proto","ensureDoActuallyStillExist","root","navigator","storage","getDirectory","DOMException","call","catch","err","unknown","next","done","$3tgc8","then","id","$110e0974a90676f8$export$6503ec6e8aabbaf","$110e0974a90676f8$export$f7ad0328861e2f03","$110e0974a90676f8$var$mapping","Map","baseUrl","manifest","i","resolved","Error","URL","toString"],"version":3,"file":"FileSystemDirectoryHandle.ad365331.js.map"}